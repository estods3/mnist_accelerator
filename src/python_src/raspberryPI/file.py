@cocotb.test()
async def test_batch1_sample21(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=1, Sample=21
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 4
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000000011000"), \
                   LogicArray("00011000111000"), \
                   LogicArray("00011100111000"), \
                   LogicArray("00011101111000"), \
                   LogicArray("00011111111000"), \
                   LogicArray("00011111110000"), \
                   LogicArray("00011111111000"), \
                   LogicArray("00000001111000"), \
                   LogicArray("00000001110000"), \
                   LogicArray("00000001110000"), \
                   LogicArray("00000001100000"), \
                   LogicArray("00000000000000"), \
    ]

    classification_result = 4

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


@cocotb.test()
async def test_batch0_sample11(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=0, Sample=11
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 6
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000110000000"), \
                   LogicArray("00001110000000"), \
                   LogicArray("00001100000000"), \
                   LogicArray("00001100011000"), \
                   LogicArray("00011101111100"), \
                   LogicArray("00011011111100"), \
                   LogicArray("00011111001100"), \
                   LogicArray("00011111001100"), \
                   LogicArray("00011111111000"), \
                   LogicArray("00001111110000"), \
                   LogicArray("00000111100000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
    ]

    classification_result = 6

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


@cocotb.test()
async def test_batch1_sample23(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=1, Sample=23
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 3
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00011111000000"), \
                   LogicArray("00111111000000"), \
                   LogicArray("00000111000000"), \
                   LogicArray("00001111000000"), \
                   LogicArray("00011111100000"), \
                   LogicArray("00011001111100"), \
                   LogicArray("00000000111000"), \
                   LogicArray("00000001111000"), \
                   LogicArray("00000011110000"), \
                   LogicArray("00000111110000"), \
                   LogicArray("00000011100000"), \
                   LogicArray("00000000000000"), \
    ]

    classification_result = 3

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


@cocotb.test()
async def test_batch1_sample13(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=1, Sample=13
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 2
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000111000000"), \
                   LogicArray("00011111110000"), \
                   LogicArray("00111000110000"), \
                   LogicArray("00110000110000"), \
                   LogicArray("00000001110000"), \
                   LogicArray("00000011100000"), \
                   LogicArray("00000111100000"), \
                   LogicArray("00000111111110"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
    ]

    classification_result = 2

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


@cocotb.test()
async def test_batch1_sample63(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=1, Sample=63
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 5
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000000011100"), \
                   LogicArray("00000011111100"), \
                   LogicArray("00001111110000"), \
                   LogicArray("00011111000000"), \
                   LogicArray("00011100000000"), \
                   LogicArray("00001111000000"), \
                   LogicArray("00000111100000"), \
                   LogicArray("00000001110000"), \
                   LogicArray("00001001110000"), \
                   LogicArray("00001111100000"), \
                   LogicArray("00000111000000"), \
                   LogicArray("00000000000000"), \
    ]

    classification_result = 5

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


@cocotb.test()
async def test_batch1_sample10(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=1, Sample=10
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 1
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000011100000"), \
                   LogicArray("00000011100000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000000000000"), \
    ]

    classification_result = 1

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


@cocotb.test()
async def test_batch0_sample5(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=0, Sample=5
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 1
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000000110000"), \
                   LogicArray("00000001110000"), \
                   LogicArray("00000001110000"), \
                   LogicArray("00000001100000"), \
                   LogicArray("00000011100000"), \
                   LogicArray("00000011100000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000111000000"), \
                   LogicArray("00000111000000"), \
                   LogicArray("00000110000000"), \
                   LogicArray("00000010000000"), \
                   LogicArray("00000000000000"), \
    ]

    classification_result = 1

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


@cocotb.test()
async def test_batch1_sample37(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=1, Sample=37
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 0
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000001110000"), \
                   LogicArray("00000111111000"), \
                   LogicArray("00001111111100"), \
                   LogicArray("00001110001100"), \
                   LogicArray("00011100001100"), \
                   LogicArray("00011000001100"), \
                   LogicArray("00011000001100"), \
                   LogicArray("00011000011100"), \
                   LogicArray("00001100111000"), \
                   LogicArray("00001111110000"), \
                   LogicArray("00000011100000"), \
                   LogicArray("00000000000000"), \
    ]

    classification_result = 0

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


@cocotb.test()
async def test_batch0_sample12(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=0, Sample=12
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 9
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000011110000"), \
                   LogicArray("00000111111000"), \
                   LogicArray("00001110111000"), \
                   LogicArray("00001100110000"), \
                   LogicArray("00001111110000"), \
                   LogicArray("00001111110000"), \
                   LogicArray("00000001100000"), \
                   LogicArray("00000011100000"), \
                   LogicArray("00000011100000"), \
                   LogicArray("00000011000000"), \
                   LogicArray("00000011000000"), \
    ]

    classification_result = 9

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


@cocotb.test()
async def test_batch0_sample18(dut):
    # THIS TEST WAS AUTOGENERATED USING data_preprocessor.py
    # Test: Batch=0, Sample=18
    # Author: estods3
    # Input: described in 'input_image'
    # Expected Result: BSD = 3
    # --------------------------------------------
    input_image = [LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00011100000000"), \
                   LogicArray("00111111000000"), \
                   LogicArray("00110111100000"), \
                   LogicArray("00111111100000"), \
                   LogicArray("00111111111000"), \
                   LogicArray("00001111111100"), \
                   LogicArray("00001100011110"), \
                   LogicArray("00001110001110"), \
                   LogicArray("00000111111110"), \
                   LogicArray("00000011111100"), \
                   LogicArray("00000000000000"), \
                   LogicArray("00000000000000"), \
    ]

    classification_result = 3

    # PERFORM TEST
    # ------------
    # Set the clock period to 10 us (100 KHz)
    clock = Clock(dut.clk, 10, units='us')
    cocotb.start_soon(clock.start())

    # Initial Conditions
    dut.ena.value = 1
    dut.ui_in.value = 128
    dut.uio_in.value = 0
    dut.rst_n.value = 0
    await ClockCycles(dut.clk, 10)
    dut.rst_n.value = 1

    # Enter 'READ' Mode
    dut.ui_in.value = 0                       # Negative Edge (start transmission)
    await ClockCycles(dut.clk, 2)
    assert int(dut.uo_out[7].value) == 0      # Confirm Outputs Invalid (flag = 0) before Image is Transmitted

    # Transmit Input Image (Serial Transmission)
    dut._log.info('Transmitting Image...')
    for row in input_image:
        dut.ui_in.value = 128 + row[13:7].integer
        await ClockCycles(dut.clk, 1)
        dut.ui_in.value = 128 + row[6:0].integer
        await ClockCycles(dut.clk, 1)
    dut._log.info('Transmitting Image...Done')

    # Wait for Additional Clock Cycle(s) Before Evaluating
    await ClockCycles(dut.clk, 10)

    # Evaluate Results
    # ----------------
    dut._log.info('Evaluating...')
    #print(dut.uo_out.value)
    #print(dut.uio_out.value)
    #print(dut.uio_oe.value)
    assert int(dut.uo_out[7].value) == 1  #Test Classification Flag set to 1
    assert int(dut.uio_oe.value) == 0xFF  #Test All Bidirectional I/O Output Enable set to '1'
    assert int(dut.uio_out.value) == classification_result
    if('1.8.1' in cocotb.__version__):
        # Flip Endian-ness in cocotb v1.8.1
        assert int(dut.uo_out.value[1:7]) == segments[classification_result]
    else:
        assert int(dut.uo_out.value[6:0]) == segments[classification_result]
    dut._log.info('Evaluating...Done')


